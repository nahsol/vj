<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tab Audio Visualizer — Black Void Nebula (Thick + Soft)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #ui{
      position:fixed; top:16px; left:16px; z-index:10;
      display:flex; gap:10px; align-items:center;
      background:rgba(10,12,18,.55); border:1px solid rgba(255,255,255,.08);
      padding:10px 12px; border-radius:14px; backdrop-filter: blur(8px);
      color:#e8eaf0; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto;
    }
    button{
      border:0; border-radius:12px; padding:10px 12px;
      background:#1b2140; color:#fff; cursor:pointer;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    input[type="range"]{ width:160px; }
    canvas{ display:block; width:100vw; height:100vh; }
    .hint{ opacity:.85; font-size:12px; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">탭 오디오 연결</button>
    <button id="stopBtn" disabled>정지</button>
    <label>감도 <input id="gain" type="range" min="0" max="2.5" step="0.01" value="1.05"></label>
    <div class="hint">공유창에서 “탭 오디오 공유” 체크</div>
  </div>

  <canvas id="c"></canvas>

  <script>
    const canvas  = document.getElementById('c');
    const ctx     = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const gainEl   = document.getElementById('gain');

    let ac, analyser, srcNode, gainNode, data;
    let stream, rafId;
    let DPR = 1;

    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(innerWidth * DPR);
      canvas.height = Math.floor(innerHeight * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener('resize', resize);
    resize();

    function energyFromBins(arr, start, end){
      let sum = 0;
      for (let i=start; i<end; i++) sum += arr[i];
      return sum / (end - start) / 255;
    }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function smoothstep(a,b,x){ x=clamp01((x-a)/(b-a)); return x*x*(3-2*x); }

    // ===== Visual State =====
    const S = []; // strokes
    let t = 0;

    // 고급 팔레트 (검은 배경에서 “예쁜 네온 안개”)
    const palette = [
      [205, 60, 60], // steel blue
      [185, 70, 55], // mint cyan
      [265, 55, 62], // violet
      [330, 55, 58], // magenta
      [35,  70, 60], // warm amber pearl
    ];

    function pickColor(seed, e){
      const c = palette[seed % palette.length];
      const h = c[0] + ((seed*23)%18 - 9) + e*10;
      const s = Math.min(85, c[1] + e*10);
      const l = Math.min(70, c[2] + e*6);
      return [h,s,l];
    }

    // ✅ “콧털” 방지: 짧은 잔선 대신 "굵은 리본/브러시 스트로크"로
    function spawnStrokes(n, e){
      for (let i=0; i<n; i++){
        const seed = (Math.random()*1e9)|0;

        // 화면 전체 + 가장자리 기원
        let x = Math.random()*innerWidth;
        let y = Math.random()*innerHeight;
        if (Math.random() < 0.40){
          const side = (Math.random()*4)|0;
          if (side===0){ x = Math.random()*innerWidth; y = -40; }
          if (side===1){ x = innerWidth+40; y = Math.random()*innerHeight; }
          if (side===2){ x = Math.random()*innerWidth; y = innerHeight+40; }
          if (side===3){ x = -40; y = Math.random()*innerHeight; }
        }

        // 긴 스트로크: 속도와 굵기는 하이/미드로
        const ang = Math.random()*Math.PI*2;
        const speed = 0.35 + e*2.1;
        const vx = Math.cos(ang) * speed;
        const vy = Math.sin(ang) * speed;

        const thickness = 1.6 + Math.random()*2.2 + e*2.2; // ✅ 굵게
        const life = 120 + Math.random()*180 + e*220;      // ✅ 더 오래 살아서 “덩어리감”
        const col = pickColor(seed, e);

        S.push({
          x,y,vx,vy,seed,life,age:0,
          w: thickness,
          col,
          pts: [[x,y]],
        });
      }
    }

    // 전역 흐름장: “털”처럼 흩날리는 난류를 줄이고, 큰 흐름을 줌
    function field(x,y,mid,high){
      const nx = (x/innerWidth  - 0.5) * 2;
      const ny = (y/innerHeight - 0.5) * 2;

      const base = 0.28 + mid*0.95;
      const shear = 0.10 + high*0.65;

      const a = Math.sin(nx*1.6 + t*0.35) + Math.cos(ny*1.2 - t*0.28);
      const b = Math.cos(nx*1.3 - t*0.22) - Math.sin(ny*1.7 + t*0.33);

      return {
        fx: a*base + Math.sin(t + ny*2.4)*shear,
        fy: b*base + Math.cos(t + nx*2.4)*shear,
      };
    }

    function draw(){
      rafId = requestAnimationFrame(draw);
      analyser.getByteFrequencyData(data);

      const mid  = energyFromBins(data, 18, 80);
      const high = energyFromBins(data, 80, 180);
      const g = parseFloat(gainEl.value);

      const energy = clamp01((mid*0.75 + high*0.95) * g);

      // ✅ 배경: "무조건 검은색" + 아주 약한 잔상만
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = `rgba(0,0,0,${0.28 + (1-energy)*0.10})`;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      t += 0.016;

      // ✅ 홍수는 하되 “화이트아웃”/“털” 방지: 양은 적당 + 스트로크 길이로 밀도 만들기
      const emit = Math.floor(3 + 14 * smoothstep(0.10, 0.70, energy));
      spawnStrokes(emit, energy);

      // cap
      if (S.length > 520) S.splice(0, S.length - 520);

      // 오디오로 blur 펌핑(요구)
      const blurPx = 0.6 + smoothstep(0.12, 0.80, energy) * 4.5;

      for (let i=S.length-1; i>=0; i--){
        const s = S[i];
        s.age++;

        const k = 1 - (s.age / s.life);
        if (k <= 0 || s.x<-420 || s.x>innerWidth+420 || s.y<-420 || s.y>innerHeight+420){
          S.splice(i,1);
          continue;
        }

        const f = field(s.x, s.y, mid, high);

        // 난류 줄이고 "큰 흐름 + 약간의 비틀림"
        const twist = (high*0.25) * Math.sin(s.seed*0.00001 + t*2.2);

        s.vx += f.fx*0.10 + twist*0.25;
        s.vy += f.fy*0.10 - twist*0.25;

        s.vx *= 0.989;
        s.vy *= 0.989;

        s.x += s.vx;
        s.y += s.vy;

        // pts
        s.pts.push([s.x, s.y]);
        const maxPts = 22 + Math.floor(energy*22);
        if (s.pts.length > maxPts) s.pts.shift();

        const [h,ss,l] = s.col;

        // ✅ 흰색 방지: 밝기(l)를 낮게 유지 + 알파 제한
        const alpha = (0.05 + energy*0.12) * (k*k);
        const outerW = (s.w * (1.2 + energy*0.8));
        const innerW = Math.max(1.0, outerW * 0.55);

        // ---- Outer soft brush (glare 느낌) ----
        ctx.save();
        ctx.filter = `blur(${blurPx}px)`;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.shadowColor = `hsla(${h},${ss}%,${Math.min(68,l)}%,${alpha*0.55})`;
        ctx.shadowBlur = 14 + energy*28;

        ctx.strokeStyle = `hsla(${h},${ss}%,${Math.min(66,l+2)}%,${alpha*0.28})`;
        ctx.lineWidth = outerW;

        ctx.beginPath();
        for (let j=0; j<s.pts.length; j++){
          const [px,py] = s.pts[j];
          if (j===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.stroke();

        // ---- Inner core (선명한 리본) ----
        ctx.filter = "none";
        ctx.shadowBlur = 0;

        ctx.strokeStyle = `hsla(${h},${ss}%,${Math.min(62,l-2)}%,${alpha*0.75})`;
        ctx.lineWidth = innerW;

        ctx.beginPath();
        for (let j=0; j<s.pts.length; j++){
          const [px,py] = s.pts[j];
          if (j===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.stroke();

        ctx.restore();
      }
    }

    // ✅ 오디오 캡처: 안정 버전 유지
    async function start(){
      try{
        stream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:true });

        ac = new (window.AudioContext || window.webkitAudioContext)();
        analyser = ac.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.84;

        gainNode = ac.createGain();
        gainNode.gain.value = 1.0;

        srcNode = ac.createMediaStreamSource(stream);
        srcNode.connect(gainNode);
        gainNode.connect(analyser);

        data = new Uint8Array(analyser.frequencyBinCount);

        startBtn.disabled = true;
        stopBtn.disabled = false;

        const [vtrack] = stream.getVideoTracks();
        if (vtrack) vtrack.onended = stop;

        if (ac.state === 'suspended') await ac.resume();

        // ✅ 강제 블랙 클리어
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,innerWidth,innerHeight);

        draw();
      } catch (e){
        console.error(e);
        alert('캡처 시작 실패. 공유창에서 "탭" 선택 + "탭 오디오 공유" 체크 확인!');
      }
    }

    function stop(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
      if (ac){ ac.close(); ac = null; }

      S.length = 0;

      startBtn.disabled = false;
      stopBtn.disabled = true;

      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
  </script>
</body>
</html>
