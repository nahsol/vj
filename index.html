<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tab Audio Visualizer — Fireflies (Black + Blur)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #ui{
      position:fixed; top:16px; left:16px; z-index:10;
      display:flex; gap:10px; align-items:center;
      background:rgba(10,12,18,.55); border:1px solid rgba(255,255,255,.08);
      padding:10px 12px; border-radius:14px; backdrop-filter: blur(8px);
      color:#e8eaf0; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto;
    }
    button{
      border:0; border-radius:12px; padding:10px 12px;
      background:#1b2140; color:#fff; cursor:pointer;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    input[type="range"]{ width:160px; }
    canvas{ display:block; width:100vw; height:100vh; }
    .hint{ opacity:.85; font-size:12px; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">탭 오디오 연결</button>
    <button id="stopBtn" disabled>정지</button>
    <label>감도 <input id="gain" type="range" min="0" max="2.5" step="0.01" value="1.10"></label>
    <div class="hint">공유창에서 “탭 오디오 공유” 체크</div>
  </div>

  <canvas id="c"></canvas>

  <script>
    const canvas  = document.getElementById('c');
    const ctx     = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const gainEl   = document.getElementById('gain');

    let ac, analyser, srcNode, gainNode, data;
    let stream, rafId;
    let DPR = 1;

    function resize(){
      // 성능 위해 DPR 상한 낮춤
      DPR = Math.max(1, Math.min(1.5, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(innerWidth * DPR);
      canvas.height = Math.floor(innerHeight * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener('resize', resize);
    resize();

    function energyFromBins(arr, start, end){
      let sum = 0;
      for (let i=start; i<end; i++) sum += arr[i];
      return sum / (end - start) / 255;
    }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function smoothstep(a,b,x){ x=clamp01((x-a)/(b-a)); return x*x*(3-2*x); }

    // ===== Fireflies =====
    const flies = [];
    const MAX_FLIES = 180; // ✅ 성능 우선
    let t = 0;

    // 예쁜 색(촌스런 빨강/파랑 금지): 민트/바이올렛/웜 펄 계열
    const fireColors = [
      [185, 80, 65], // mint
      [210, 70, 66], // cool blue-lavender
      [265, 70, 68], // violet
      [330, 70, 66], // magenta
      [35,  85, 66], // warm pearl
    ];

    function pickColor(){
      const c = fireColors[(Math.random()*fireColors.length)|0];
      const h = c[0] + (Math.random()*10 - 5);
      const s = c[1] + (Math.random()*8  - 4);
      const l = c[2] + (Math.random()*8  - 4);
      return [h,s,l];
    }

    function newFly(boost){
      const [h,s,l] = pickColor();
      return {
        x: Math.random()*innerWidth,
        y: Math.random()*innerHeight,
        vx: (Math.random()-0.5) * (0.15 + boost*0.9),
        vy: (Math.random()-0.5) * (0.15 + boost*0.9),
        baseR: 0.8 + Math.random()*1.8,
        h,s,l,
        phase: Math.random()*Math.PI*2,     // 깜빡임 위상
        freq:  0.6 + Math.random()*1.1,     // 기본 깜빡임 속도
        life:  80 + Math.random()*220,      // 대충 살아있다 사라짐
        age: 0,
        burst: 0,                           // 오디오로 번쩍
      };
    }

    function ensureFlies(n, boost){
      while (flies.length < n) flies.push(newFly(boost));
    }

    function draw(){
      rafId = requestAnimationFrame(draw);
      analyser.getByteFrequencyData(data);

      const mid  = energyFromBins(data, 18, 80);
      const high = energyFromBins(data, 80, 180);

      const g = parseFloat(gainEl.value);
      const energy = clamp01((mid*0.75 + high*0.95) * g);
      const m = smoothstep(0.10, 0.75, energy);

      t += 0.016;

      // ✅ 배경은 "무조건 검정" + 약간의 잔상(너무 밝아지지 않게)
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = `rgba(0,0,0,${0.35 + (1-m)*0.12})`;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // 파티클(반딧불이) 수: 음악이 차오를수록 조금 늘기
      const target = Math.floor(70 + m*90);   // 70~160
      ensureFlies(Math.min(MAX_FLIES, target), m);

      // ✅ 블러 “좀 제발”: 전체 블러 강도를 음악으로 펌핑
      const blurPx = 2 + m*10;                // 2~12
      ctx.filter = `blur(${blurPx}px)`;

      // 합성은 screen만 아주 약하게(화이트아웃 방지: 알파로 제어)
      // screen은 불빛에만 사용하되, 배경은 이미 검정이라 안전
      ctx.globalCompositeOperation = "screen";

      for (let i=flies.length-1; i>=0; i--){
        const f = flies[i];
        f.age++;

        // 오래된 애는 교체
        if (f.age > f.life){
          flies[i] = newFly(m);
          continue;
        }

        // 오디오가 올라가면 "갑자기 움직임" 확률 증가
        const twitchProb = 0.004 + m*0.03;
        if (Math.random() < twitchProb){
          f.vx += (Math.random()-0.5) * (0.9 + m*2.0);
          f.vy += (Math.random()-0.5) * (0.9 + m*2.0);
          f.burst = Math.min(1, f.burst + 0.7); // 순간 번쩍
        }

        // 부드러운 드리프트 + 약간의 감쇠
        f.vx += (Math.sin(t*0.9 + f.phase)*0.004) * (0.5 + m*1.6);
        f.vy += (Math.cos(t*0.8 + f.phase)*0.004) * (0.5 + m*1.6);
        f.vx *= 0.94;
        f.vy *= 0.94;

        f.x += f.vx;
        f.y += f.vy;

        // 화면 밖으로 나가면 워프
        if (f.x < -40) f.x = innerWidth + 40;
        if (f.x > innerWidth + 40) f.x = -40;
        if (f.y < -40) f.y = innerHeight + 40;
        if (f.y > innerHeight + 40) f.y = -40;

        // 깜빡임: 기본 싸인 + high에서 더 촘촘하게(하이/미드 반영)
        const blink = 0.5 + 0.5 * Math.sin(f.phase + t*(f.freq + high*2.6));
        const shimmer = smoothstep(0.35, 1.0, blink); // 꺼졌다 켜졌다 확실하게

        // burst는 서서히 사라짐
        f.burst *= 0.90;

        // 밝기/크기: 오디오 반영 (하이-미드에 반응)
        const intensity = clamp01( (shimmer*0.55 + f.burst*0.7) * (0.35 + m*1.15) );
        const r = f.baseR * (1.0 + intensity*3.0);

        // 색: 너무 하얘지지 않게 L 제한
        const L = Math.min(72, f.l + intensity*10);

        // 실제 그리기(선 없음, 점/글로우만)
        // 중심 코어
        ctx.fillStyle = `hsla(${f.h},${f.s}%,${L}%,${0.10 + intensity*0.22})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, r, 0, Math.PI*2);
        ctx.fill();

        // 외곽 글로우(두겹)
        ctx.fillStyle = `hsla(${f.h},${f.s}%,${L}%,${0.05 + intensity*0.12})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, r*2.1, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = `hsla(${f.h},${f.s}%,${L}%,${0.03 + intensity*0.08})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, r*3.6, 0, Math.PI*2);
        ctx.fill();
      }

      // 필터 원복
      ctx.filter = "none";
      ctx.globalCompositeOperation = "source-over";
    }

    // ✅ 오디오 캡처: 안정 버전 유지
    async function start(){
      try{
        stream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:true });

        ac = new (window.AudioContext || window.webkitAudioContext)();
        analyser = ac.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.86;

        gainNode = ac.createGain();
        gainNode.gain.value = 1.0;

        srcNode = ac.createMediaStreamSource(stream);
        srcNode.connect(gainNode);
        gainNode.connect(analyser);

        data = new Uint8Array(analyser.frequencyBinCount);

        startBtn.disabled = true;
        stopBtn.disabled = false;

        const [vtrack] = stream.getVideoTracks();
        if (vtrack) vtrack.onended = stop;

        if (ac.state === 'suspended') await ac.resume();

        // 강제 블랙 클리어
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,innerWidth,innerHeight);

        flies.length = 0;
        draw();
      } catch (e){
        console.error(e);
        alert('캡처 시작 실패. 공유창에서 "탭" 선택 + "탭 오디오 공유" 체크 확인!');
      }
    }

    function stop(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
      if (ac){ ac.close(); ac = null; }

      flies.length = 0;

      startBtn.disabled = false;
      stopBtn.disabled = true;

      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
  </script>
</body>
</html>
